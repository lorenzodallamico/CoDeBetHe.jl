var documenterSearchIndex = {"docs":
[{"location":"man/dynamic_CD/#Dynamic-community-detection","page":"Dynamic CD","title":"Dynamic community detection","text":"","category":"section"},{"location":"man/dynamic_CD/#Create-a-synthetic-graphs","page":"Dynamic CD","title":"Create a synthetic graphs","text":"","category":"section"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"The package CoDeBetHe allows to generate graphs with communities according to the dynamical degree corrected stochastic block model (D-DCSBM). ","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"Let T be the number of different snapshots that compose the dynamical graph mathcalG_t_t=1dotsT. Suppose that each graph is composed by n nodes and k communities, with label vector bmell_t in 1dotsk^n and the adjacency matrix A^(t) in 01^ntimes n for 1leq tleq T. \nThe label vector bmell_t = 1 is initialized so that pi_acdot n nodes have label a. The labels are then updated for 2 leq t leq T according to the Markov process, where ell_i_t denote the label of node i at time t.","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"ell_i_t = begincases\nell_i_t-1rm wp eta \na  rm wp (1-eta)pi_a a in 1dots k\nendcases","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"Once the vector label is created, each adjacency matrix A^(t) is drawn independently at random according to the degree-corrected stochastic block model (see Static community detection. The following lines of codes allow to generate a a graph sequence according to the D-DCSBM. First we initialize the parameters of the DCSBM","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"For a more precise description of the DCSBM, please refer to the Static community detection section.","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"using CoDeBetHe\nusing Distributions, DelimitedFiles, LinearAlgebra, DataFrames, StatsBase\n\n\n## Parameter initialization\n\nn = floor(Int64,10^(3.5)) # size of the networks (number of nodes)\nk = 10 # number of clusters (k)\nη = 0.7 # label persistence\nT = 6 # number of time-steps\n\n### vector θ\n\nθ = rand(Uniform(3, 10),n).^3\nθ = θ./mean(θ)\nΦ = mean(θ.^2)\n\n### vector π\n\nvar_π = 1\nπ_v = abs.(rand(Normal(1/k,var_π/(2*k)),k))\nπ_v = π_v/sum(π_v)\n\n### matrix C\n\nc = 8. # expected average degree\nc_out = 1.5 # expected off diagonal-elements of C\nf = 1/k # fluctuation of off diagonal elements\nC = matrix_C(c_out,c,f,π_v) # creation of the matrix C","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"We then create the sequences bmell_t_t=1dotsT and A^(t)_t = 1dotsT","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"AT, ℓ_T = adjacency_matrix_DDCSBM(T, C, c, η, θ, π_v)","category":"page"},{"location":"man/dynamic_CD/#Load-a-synthetic-data-set","page":"Dynamic CD","title":"Load a synthetic data-set","text":"","category":"section"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"At github.com/lorenzodallamico/CoDeBetHe, you can find the data-set needed to run the following example. The data are taken from the SocioPattern project. ","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"note: Note\nIf using this dataset, please give reference to the followings articles:Mitigation of infectious disease at school: targeted class closure vs school closure,\nHigh-Resolution Measurements of Face-to-Face Contact Patterns in a Primary School, PLOS ONE 6(8): e23176 (2011)","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"# Load the data\n\nedge_list = convert(Array{Int64}, readdlm(\"datasets/el_primary.dat\")) # this loads the edge list\nindex = convert(Array{Int64}, readdlm(\"datasets/index_primary.dat\")) # this list is to identifies the identities corresponding to each node \ntt = convert(Array{Int64}, readdlm(\"datasets/times_primary.dat\")) # this loads the time at which an edges was present\n\nid = findall(index .== 1)\nindex = [id[i][1] for i=1:length(id)]\n\n# Generate the temporal graph\n\nT = maximum(tt)\nn = maximum(unique(edge_list))+1\nAT = [spdiagm(0 => zeros(n)) for i=1:T]\n\nedge_list[:,1] = edge_list[:,1] .+ 1\nedge_list[:,2] = edge_list[:,2] .+ 1\n\nfor t=1:T\n    idx = Array(findall(tt .== t))\n    idx = [idx[i][1] for i=1:length(idx)]\n    el = edge_list[idx,:]\n    AT[t] = sign.(sparse(el[:,1],el[:,2], ones(length(el[:,1])), n,n)) # create sparse adjacency matrix\n    AT[t] = AT[t][index,index]\n    AT[t] = AT[t] + AT[t]'\nend\n\nn = length(index)\nT = findmin([sum(AT[t]) for t=1:T])[2]-2\nAT = AT[1:T]","category":"page"},{"location":"man/dynamic_CD/#Infer-the-community-structure-from-\\{A{(t)}\\}_{t-1,\\dots,T}","page":"Dynamic CD","title":"Infer the community structure from A^(t)_t = 1dotsT","text":"","category":"section"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"We will show the basic usage of the function dynamic_community_detection_BH, applied to the SocioPattern network. For a more specific use of the outputs, please refer to the documentation of dynamic_community_detection_BH.","category":"page"},{"location":"man/dynamic_CD/","page":"Dynamic CD","title":"Dynamic CD","text":"using CoDeBetHe, Distributions, DelimitedFiles, LinearAlgebra, DataFrames, StatsBase, SparseArrays # hide\nusing  Plots # hide\n\n\nedge_list = convert(Array{Int64}, readdlm(\"/home/lorenzo/CoDeBetHe/docs/data_for_doc/el_primary.dat\")) # hide\nindex = convert(Array{Int64}, readdlm(\"/home/lorenzo/CoDeBetHe/docs/data_for_doc/index_primary.dat\")) # hide\ntt = convert(Array{Int64}, readdlm(\"/home/lorenzo/CoDeBetHe/docs/data_for_doc/times_primary.dat\")) # hide\n\nid = findall(index .== 1) # hide\nindex = [id[i][1] for i=1:length(id)] # hide\nT = maximum(tt) # hide\nn = maximum(unique(edge_list))+1 # hide\nAT = [spdiagm(0 => zeros(n)) for i=1:T] # hide\n\nedge_list[:,1] = edge_list[:,1] .+ 1 # hide\nedge_list[:,2] = edge_list[:,2] .+ 1 # hide\n\nfor t=1:T # hide\n    idx = Array(findall(tt .== t)) # hide\n    idx = [idx[i][1] for i=1:length(idx)] # hide\n    el = edge_list[idx,:] # hide\n    AT[t] = sign.(sparse(el[:,1],el[:,2], ones(length(el[:,1])), n,n)) # hide\n    AT[t] = AT[t][index,index] # hide\n    AT[t] = AT[t] + AT[t]' # hide\nend # hide\n\nn = length(index) # hide\nT = findmin([sum(AT[t]) for t=1:T])[2]-2 # hide\nAT = AT[1:T] # hide\n\nη = 0.55 # chose the value of η\nk = 10 # set the number of communities \n\n\"\"\"Optional inputs\"\"\"\n\napprox_embedding = false # if true, uses the compressive approximate embedding. \n# Else, full computation of the eigenspace associated to the negative eigenvalues of H\n\nm = nothing # (useful only if approx_embedding == true); either set m to a nothing value,\n# and an automatic m will be estimated (usually, the larger n, the larger the required m, \n# the longer the computation) or set m to an Int64 if you want to specify the polynomial \n# order used for the approximation (as a general rule: the larger m, the more precise the \n# approximate embedding, thus the better the result, but the longer the computation time)\n\nverbose = 1; #set to 0 for no verbosity; 1 for some verbosity\n\n\ncluster = dynamic_community_detection_BH(AT, η, k; approx_embedding = approx_embedding, m = m, verbose=verbose)\n# t_v = Array(0:T-1)*15/60 .+ 8.5 # hide\n# plot(t_v, cluster.modularity, marker = :dot, color = :orange, linewidth = 3, xlabel = \"Time\", ylabel = \"Modularity\", label = \"\") # hide","category":"page"},{"location":"man/static_CD/#Static-community-detection","page":"Static CD","title":"Static community detection","text":"","category":"section"},{"location":"man/static_CD/#Create-a-synthetic-graphs","page":"Static CD","title":"Create a synthetic graphs","text":"","category":"section"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"The package CoDeBetHe allows to generate graphs with communities according to the degree corrected stochastic block model (DC-SBM). ","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"Let mathcalG be a graph with n nodes and k communities.  Let bmell in 1dotsk^n be the label vector and A in 01^ntimes n the adjacency matrix whose entry A_ij=1 if and only if (ij) is an edge of mathcalG. \nThe vector bmtheta in mathbbR^n, satisfying frac1nsum_itheta_i = 1 and frac1nsum_itheta_i^2 = Phi, for some Phi in mathbbR. The expected degree of the node i will be proportional to theta_i and therefore the vector bmtheta can be used to reproduce an arbitrary degree distribution in the graph mathcalG.\nThe matrix CinmathbbR^ktimes k then contains at its entry C_ab the affinity between class a and class b. ","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"The entries of the adjacency matrix A are generated independently at random according to","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"mathbbP(A_ij = 1ell_iell_j) = theta_itheta_j fracC_ell_iell_jn","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"The following lines of codes allow to generate a graph with communities according to the DC-SBM","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"using CoDeBetHe\nusing Distributions, DelimitedFiles, LinearAlgebra, DataFrames, StatsBase\n\nn = floor(Int64,10^(4)) # size of the network (number of nodes)\nk = 10 # number of clusters (k)\n\n### vector θ\nθ = rand(Uniform(3, 10),n).^3.5 # with this we induce a power law degree distribution\nθ = θ./mean(θ) # we impose that \\sum_i \\theta_i = n","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"note: Note\nThe definition of the vector θ should be made according to the degree distribution distribution one whishes to have. In this example we would obtain a power law degree degree distribution, while for a homogeneous degree distribution (recovering the classical stochastic block model), one should simply set theta_i = 1foralli. The normalization line should not be changed, instead.","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"We now proceed choosing the size of each class. To do so we introduce a vector bmpi in mathbbR^k whose entry pi_a indicates the fraction of nodes that are in class a left(sum_a = 1^k pi_a = 1right). We then define matrix Pi = rm diag(bmpi). Here is an example of how to build the vector bmpi, using gaussian random variables, centered in 1k.","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"### vector π\nπ_v = abs.(rand(Normal(1/k,1/(2*k)),k)) # we take the abs, because π_v[i] > 0 for all i\nπ_v = π_v/sum(π_v) # Normalize the vector (do not change this line)\n","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"Finally, we create the matrix C  with the function matrix_C. The matrix C is created so that all the rows of the matrix CPi sum up to c, the expected average degree of the network. This conditions implies that the expected average degree is independent of the class: otherwise, by simply looking at the degree distribution one could infer the community structure.\nFurther degrees of freedom in the definition of  C are added through the the parameter f which is such that the off-diagonal elements are drown from a gaussian distribution with average c_out and hence are not equal. If one wants all the off-diagonal elements to be equal, simply set f = 0. The following lines create the matrix C.","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"### matrix C\nc = 10. # average degree\nc_out = 2. # average value of off-diagonal terms\nf = 2/k # fluctuation of off-diagonal terms\nC = matrix_C(c_out,c,f,π_v) # matrix C\n","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"Given the vectors bmpi bmtheta and the matrix C, we then generate the ground truth vector bmell and the adjacency matrix A\t","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"ℓ = create_label_vector(n, k, π_v) # create the label vector\nA = adjacency_matrix_DCSBM(C,c,ℓ,θ) # create the adjacency matrix of an instance of DC-SBM","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"note: Note\nThe matrix A is stored in sparse format, through its edge list representation. Moving to a dense representation would drastically increase the computational cost.","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"The following plot shows a toy example of the output of adjacency_matrix_DCSBM on a small network with large average degree and four communities of different sizes.","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"using CoDeBetHe, LinearAlgebra, Distributions # hide\nusing  Plots # hide\n\nn = floor(Int64,10^(2.5)) # hide\nk = 4 # hide\n\nθ = rand(Uniform(3, 10),n).^0 # hide\nθ = θ./mean(θ) # hide\n\nπ_v = Array([0.1,0.4,0.2,0.3]) # hide\nΠ = Diagonal(π_v) # hide\n\nc = 100. # hide\nc_out = 20. # hide\nC = matrix_C(c_out,c,0.,π_v) # hide\n\nℓ = create_label_vector(n, k, π_v) # hide\nA = adjacency_matrix_DCSBM(C,c,ℓ,θ) # hide\n\nheatmap(Array(A), c =cgrad([:white, :blue]))  # hide","category":"page"},{"location":"man/static_CD/#Load-a-real-graphs","page":"Static CD","title":"Load a real graphs","text":"","category":"section"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"At https://github.com/lorenzodallamico/CoDeBetHe, at the directory datatasets one can find some real datasets on which our algorithm can tested. Once dataset.zip has been unzipped, run the following commands to upload one of the networks","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"using CoDeBetHe\nusing Distributions, DelimitedFiles, LinearAlgebra, DataFrames, StatsBase\n\n\"\"\"\nthe datasets are called\nkarate, dolphins, polbooks, football, email, polblogs, tv, fb, power, politicians, Gnutella, vip\n\"\"\"\n\nel = convert(Array{Int64}, readdlm(\"datasets/Gnutella.txt\")) # upload edge_list: here you should be putting the name of the dataset you wish to upload\n\n# we let for all networks, the label i.d. range from 1 to n (not from 0 to n-1)\n\nif minimum(el) == 0\n    el[:,1] = el[:,1] .+ 1\n    el[:,2] = el[:,2] .+ 1\nend\n\nfs = vcat(el[:,1],el[:,2]) # symmetrize the edges (ij), (ji)\nss = vcat(el[:,2],el[:,1])\n\nedge_list = hcat(fs,ss) # create edge list\nn = length(unique(edge_list)) # find the value of n\nA = sparse(edge_list[:,1],edge_list[:,2], ones(length(edge_list[:,1])), n,n) # create sparse adjacency matrix","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"note: Note\nThe references for the datasets areKarate : Wayne W Zachary. An information flow model for conflict and fission in small groups.Journalof anthropological research, 33(4):452–473, 1977.\nDolphins : David Lusseau, Karsten Schneider, Oliver J Boisseau, Patti Haase, Elisabeth Slooten, andSteve M Dawson.   The bottlenose dolphin community of doubtful sound features a largeproportion of long-lasting associations.Behavioral Ecology and Sociobiology, 54(4):396–405,2003.\nPolbooks : www.orgnet.com\nFootball : Michelle Girvan and Mark EJ Newman. Community structure in social and biological networks.Proceedings of the national academy of sciences, 99(12):7821–7826, 2002.\nPolblogs: Lada A Adamic and Natalie Glance. The political blogosphere and the 2004 us election:divided they blog. In Proceedings of the 3rd international workshop on Link discovery,pages 36–43. ACM, 2005.All other datasets are taken from the Stanford Network Analysis Project website page http://snap.stanford.edu/Jure Leskovec and Andrej Krevl. SNAP Datasets: Stanford large network dataset collection.http://snap.stanford.edu/data, June 2014.","category":"page"},{"location":"man/static_CD/#Infer-the-community-structure-from-A","page":"Static CD","title":"Infer the community structure from A","text":"","category":"section"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"Once we have the matrix A, we can run our Algorithm for community detection. This is done through the function community_detection_optimal_BH which is an efficient implementation of Algorithm 2 of A unified framework for spectral clustering in sparse graphs. Below you can find the basic use of this function (run on Political blogs) with the typical output of the function. For more details see the documentation of community_detection_optimal_BH.","category":"page"},{"location":"man/static_CD/","page":"Static CD","title":"Static CD","text":"using CoDeBetHe # hide\nusing Distributions, DelimitedFiles, LinearAlgebra, DataFrames, StatsBase, SparseArrays # hide\n\n\nel = convert(Array{Int64}, readdlm(\"/home/lorenzo/CoDeBetHe/docs/data_for_doc/polblogs.txt\")) # hide\n\n\nif minimum(el) == 0 # hide\n    el[:,1] = el[:,1] .+ 1 # hide\n    el[:,2] = el[:,2] .+ 1 # hide\nend # hide\n\nfs = vcat(el[:,1],el[:,2]) # hide\nss = vcat(el[:,2],el[:,1]) # hide\n\nedge_list = hcat(fs,ss) # hide\nn = length(unique(edge_list)) # hide\nA = sparse(edge_list[:,1],edge_list[:,2], ones(length(edge_list[:,1])), n,n) # hide\n\n\nverbose = 1; #set to 0 for no verbosity; 1 for some verbosity; 2 for full verbosity\nk_prior = 2; # if you know k in advance, set it here. If not, it is estimated\ncluster = community_detection_optimal_BH(A; k = k_prior, verbose = verbose) # run the community detection algorithm\n\nprintstyled(\"\\nThe modularity obtained is: mod = \", cluster.modularity; color = 9)","category":"page"},{"location":"#CoDeBetHe","page":"CoDeBetHe","title":"CoDeBetHe","text":"","category":"section"},{"location":"","page":"CoDeBetHe","title":"CoDeBetHe","text":"This module allows to perform Community Detection with the Bethe Hessian matrix on sparse unweighted and undirected graphs. The module is composed mainly of two algorithms, one for static community detection, following the results presented in A unified framework for spectral clustering in sparse graphs and Revisiting the Bethe-Hessian: Improved Community Detection in Sparse Heterogeneous Graphs and one for dynamic community detection, following  Community detection in sparse time-evolving graphs with a dynamical Bethe-Hessian.","category":"page"},{"location":"","page":"CoDeBetHe","title":"CoDeBetHe","text":"If you use CoDeBetHe, please consider to cite the related articles.","category":"page"},{"location":"","page":"CoDeBetHe","title":"CoDeBetHe","text":"This implementations introduce further tricks to make the algorithms more efficent. In order to use CoDeBetHe, open your terminal and type","category":"page"},{"location":"","page":"CoDeBetHe","title":"CoDeBetHe","text":"julia\npkg> add https://github.com/lorenzodallamico/CoDeBetHe","category":"page"},{"location":"","page":"CoDeBetHe","title":"CoDeBetHe","text":"In the next we will show how to use the main packages for static and dynamic community detection.","category":"page"},{"location":"","page":"CoDeBetHe","title":"CoDeBetHe","text":"","category":"page"},{"location":"man/useful_functions/#Useful-functions","page":"Useful functions","title":"Useful functions","text":"","category":"section"},{"location":"man/useful_functions/","page":"Useful functions","title":"Useful functions","text":"Here we report the documentation of some useful functions, used both in the static and dynamic settings.","category":"page"},{"location":"man/useful_functions/","page":"Useful functions","title":"Useful functions","text":"matrix_C\ncreate_label_vector\nadjacency_matrix_DCSBM\ncommunity_detection_optimal_BH\nadjacency_matrix_DDCSBM\ndynamic_community_detection_BH","category":"page"},{"location":"man/useful_functions/#CoDeBetHe.matrix_C","page":"Useful functions","title":"CoDeBetHe.matrix_C","text":"For a given diagonal matrix Π, with Tr(Π) = 1, this function generates a class affinity matrix C such that CΠ has the all ones vector as leading eigenvector with eigenvalue equal to c. The parameter f allows to add randomness in the elements of C ∈ R^{k×k}\n\nUsage\n\nC = matrix_C(c_out,c,f,π_v)\n\nEntry\n\nc_out: average value of the off-diagonal terms  of the matrix C (Float64)\nc : leading eigenvalue of CΠ (Float64)\nf : variance of the off-diagonal terms of the matrix C (Float64)\nπ_v : vector of size k containing the diagonal elements of Π (Array{Float64,1})\n\nReturns\n\nC : matrix C (Array{Float64,2})\n\n\n\n\n\n","category":"function"},{"location":"man/useful_functions/#CoDeBetHe.create_label_vector","page":"Useful functions","title":"CoDeBetHe.create_label_vector","text":"This function generates a label vector of size n, given the class sizes\n\nUsage\n\nℓ = create_label_vector(n, k, π_v)\n\nEntry\n\nn : number of nodes (Int64)\nk : number of classes (Int64)\nπ_v : vector of size k; the i-th entry corresponds to the fraction of nodes with  label equal to i,           so that ∑ π_v = 1 (Array{Float64,1})\n\nReturns\n\nℓ : label vector (Array{Int64,1})\n\n\n\n\n\n","category":"function"},{"location":"man/useful_functions/#CoDeBetHe.adjacency_matrix_DCSBM","page":"Useful functions","title":"CoDeBetHe.adjacency_matrix_DCSBM","text":"This function generates the sparse representation of an adjacency matrix A ∈ R^{n×n} according to the degree-corrected stochastic block model.\n\nUsage\n\nA = adjacency_matrix_DCSBM(C::Array{Float64,2},c::Float64,ℓ::Array{Int64,1},θ::Array{Float64,1})\n\nEntry\n\nC : class affinity matrix C (Array{Float64,2})\nc : average degree (Float64)\nℓ : label vector of size n (Array{Int64,1})\nθ : vector generating an arbitrary degree distribution. The value cθ_i is the expected degree of node i (Array{Float64,1})\n\nReturns\n\nA : sparse representation of the adjacency matrix (SparseMatrixCSC{Float64,Int64})\n\n\n\n\n\n","category":"function"},{"location":"man/useful_functions/#CoDeBetHe.community_detection_optimal_BH","page":"Useful functions","title":"CoDeBetHe.community_detection_optimal_BH","text":"This function performs community detection of a graph, according to Algorithm 2 of (Dall'Amico 2020)\n\nUsage\n\ncluster = community_detection_optimal_BH(A; k, ℓ, ϵ, projection, k_max, verbose)\n\nEntry\n\nA : sparse representation of the adjacenccy matrix (SparseMatrixCSC{Float64,Int64})\n\nOptional inputs\n\nk : number of classes (Int64). If not provided, it is estimated\nℓ : ground-truth vector (Array{Int32,1}). If not provided, the overlap will not be computed.\nϵ : precision error (Float64). If not provided, it is set to 2*10^(-5)\nprojection : (Bool) if true, the embedding on which k-means is run will be projected on the unitary hypersphere.                  Default is true.\nverbose : (0, 1, or 2) if 0, nothing is printed. If 1, some information is printed. If 2, more information is printed. Default is 1.\n\nReturns\n\ncluster.ℓ : estimated assignement vector (Array{Int64,1})\ncluster.k : number of classes obtained (Int64)\ncluster.overlap : overlap obtained (Float64)\ncluster.modularity : modularity obtained (Float64)\ncluster.ζ : vector containing the values of ζ_p for 2≤p≤k (Array{Float64,1})\n\n\n\n\n\n","category":"function"},{"location":"man/useful_functions/#CoDeBetHe.adjacency_matrix_DDCSBM","page":"Useful functions","title":"CoDeBetHe.adjacency_matrix_DDCSBM","text":"This function generates a series of T adjacency matrices A_t ∈ R^{n×n} in sparse represention from the dynamical degree-corrected stochastic block model\n\nUsage\n\nAT, ℓ_T = adjacency_matrix_DDCSBM(T, C, c, η, θ, π_v)\n\nEntry\n\nT: number of time steps (Int64)\nC : matrix C (Array{Float64,2})\nc : average degree (Float64)\nη : label persistence (Float64)\nθ : vector generating an arbitrary degree distribution. The value cθ_i is the expected degree of node i           (Array{Float64,1})\nπ_v : vector of size k; the i-th entry corresponds to the fraction of nodes with  label equal to i,           so that ∑ π_v = 1 (Array{Float64,1})\n\nReturns\n\nAT : At[t] is the sparse representation of the adjacency matrix at time t (Array{SparseMatrixCSC{Float64,Int64},1})\nℓ_T : the entry ℓ_T[t,i] contains the label of node i at time t (T×n Array{Int64,2})\n\n\n\n\n\n","category":"function"},{"location":"man/useful_functions/#CoDeBetHe.dynamic_community_detection_BH","page":"Useful functions","title":"CoDeBetHe.dynamic_community_detection_BH","text":"This function implements algorithm 1 of (Dall'Amico 2020) for dynamical community detection.\n\nUsage\n\ncluster = dynamic_community_detection_BH(AT, η, k; ℓ_T, approx_embedding, verbose, m)\n\nEntry\n\nAT : At[t] is the sparse representation of the adjacency matrix at time t   (Array{SparseMatrixCSC{Float64,Int64},1})\nη : label persistence (Float64)\nk : number of communities (Int64)\n\nOptional inputs\n\nℓ_T : the entry ℓ_T[t,i] contains the label of node i at time t (T×n Array{Int64,2}). If not available, the overlap with the ground-truth is not computed.\napprox_embedding : (Bool), if true the informative eigenvectors are obtained using the approximate procedure                        detailed in Algorithm 2 of (Dall'Amico 2020). By default  set to false\nverbose : (0, 1, or 2) if 0, nothing is printed. If 1, some information is printed. If 2, more information is printed. Default is 1.\nm : order  of the polynomial approximation (Int64). If m is not known, an adaptive choice for m will be  adopted. By default set to nothing\n\nReturns\n\ncluster.modularity : cluster.modularity[t] is the modularity obtained at time t (Array{Float64,1})\ncluster.overlap : cluster.overlap[t] is the overlap obtained at time t (Array{Float64,1})\ncluster.ℓ : cluster.ℓ[t,i] is the vector of the estimated label i at time t (Array{Array{Int64,1},1})\n\n\n\n\n\n\n\n","category":"function"}]
}
